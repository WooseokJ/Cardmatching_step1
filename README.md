## 구현 과정
step1) 먼저 1~8의 배열 3묶음을 하나의 ArrayList에 담은뒤 Collecions클래스의 shuffle을 통해 섞었습니다.

step2) 하나의 ArrayList들중 18를 뽑아 board라는 배열에 담는 작업을 하였고 이를 출력합니다.
이떄 제가 고민했던 부분은 24개의 카드중 18개의 원소를 뽑을떄 18개의 원소가 서로 짝을 이루게 뽑는방법에대해 고민을 많이하였고 18개를 뽑으면 짝이 안맞는 것들이 남아 게임이 계속 재실행하는 상황이 생기는게 의아했습니다. 

step3) 입력값이 유효한지 여부를 판단하여 두개의 좌표값을통해 board를 비교하여 카드를 보여주었습니다.
이떄 제가 신경썻던 부분은 입력값에서 해당 입력값이 유효한지아닌지에대해 에러처리입니다. 처음엔 정규식을 써서 해결할까 하다가 java문법 에러처리문과 enum을 통해 CustomError를 활용해보고싶어서 선택하게되었습니다.

step4) 해당 입력이끝나면 남아있는 카드가 원소가 아직 짝을 이루는것이 남아있는지 여부를 판단하였습니다.
이떄 제가 신경썻던 부분은 여부는 판단여부는 HashMap을 활용하여 각 원소에대한 개수를 카운트하고 각 숫자별로 원소개수는 최대 3장이므로 2개의 짝이 남아있는지 여부를 이용해 판단하였습니다.

step5) 게임종료 메세지 콘솔출력

## 메서드 정리 

 * CardMatchingGame: 객체 선언시 초기화 과정.
 * initializeDeck: 24 개 1~8 3묶음 뽑고 섞기.
 * setupBoard: 24개중 18개 카드 넣기
 * showBoard: 콘솔에 출력.
 * inputCoordinator: 입력받는 좌표 반환.
 * isInteger: 해당 값이 정수인지 아닌지 판단.
 * playGame: 게임 시작
 * gameOver:  모든카드가 다 뒤집어지면 게임종료와 함께 정보 출력.
 * checkCard: 현재 카드의 숫자들의 원소개수 카운팅한뒤에 뒤집을 카드가 남아있는지 아닌지 return
 * areAllValuesCheck: 현재 뒤집을수있는 카드가 남아있는지 아닌지 판단.
    
